{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "187e7468",
   "metadata": {
    "id": "eYrSpUncKGSk"
   },
   "source": [
    "# Faster predictions by caching"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9565f862",
   "metadata": {
    "id": "PLuPjfS7KLQ-"
   },
   "source": [
    "The default behaviour of `predict_f` in GPflow models is to compute the predictions from scratch on each call. This is convenient when predicting and training are interleaved, and simplifies the use of these models. There are some use cases, such as Bayesian optimisation, where prediction (at different test points) happens much more frequently than training. In these cases it is convenient to cache parts of the calculation which do not depend upon the test points, and reuse those parts between predictions.\n",
    "\n",
    "There are three models to which we want to add this caching capability: GPR, (S)VGP and SGPR. The VGP and SVGP can be considered together; the difference between the models is whether to condition on the full training data set (VGP) or on the inducing variables (SVGP)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77c3be11",
   "metadata": {
    "id": "EACkO-iRKM5T"
   },
   "source": [
    "## Posterior predictive distribution\n",
    "\n",
    "The posterior predictive distribution evaluated at a set of test points $\\mathbf{x}_*$ for a Gaussian process model is given by:\n",
    "\\begin{equation*}\n",
    "p(\\mathbf{f}_*|X, Y) = \\mathcal{N}(\\mu, \\Sigma)\n",
    "\\end{equation*}\n",
    "\n",
    "In the case of the GPR model, the parameters $\\mu$ and $\\Sigma$ are given by:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nm}[K_{mm} + \\sigma^2I]^{-1}\\mathbf{y}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nm}[K_{mm} + \\sigma^2I]^{-1}K_{mn}\n",
    "\\end{equation*}\n",
    "\n",
    "The posterior predictive distribution for the VGP and SVGP model is parameterised as follows:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nu}K_{uu}^{-1}\\mathbf{u}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nu}K_{uu}^{-1}K_{un}\n",
    "\\end{equation*}\n",
    "\n",
    "Finally, the parameters for the SGPR model are:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nu}L^{-T}L_B^{-T}\\mathbf{c}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nu}L^{-T}(I - B^{-1})L^{-1}K_{un}\n",
    "\\end{equation*}\n",
    "\n",
    "Where the mean function is not the zero function, the predictive mean should have the mean function evaluated at the test points added to it."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "74548145",
   "metadata": {
    "id": "GX1U-fYPKPrt"
   },
   "source": [
    "## What can be cached?\n",
    "\n",
    "We cache two separate values: $\\alpha$ and $Q^{-1}$. These correspond to the parts of the mean and covariance functions respectively which do not depend upon the test points. In the case of the GPR these are the same value:\n",
    "\\begin{equation*}\n",
    "    \\alpha = Q^{-1} = [K_{mm} + \\sigma^2I]^{-1}\n",
    "\\end{equation*}\n",
    "in the case of the VGP and SVGP model these are:\n",
    "\\begin{equation*}\n",
    "    \\alpha = K_{uu}^{-1}\\mathbf{u}\\\\ Q^{-1} = K_{uu}^{-1}\n",
    "\\end{equation*}\n",
    "and in the case of the SGPR model these are:\n",
    "\\begin{equation*}\n",
    "    \\alpha = L^{-T}L_B^{-T}\\mathbf{c}\\\\ Q^{-1} = L^{-T}(I - B^{-1})L^{-1}\n",
    "\\end{equation*}\n",
    "\n",
    "\n",
    "Note that in the (S)VGP case, $\\alpha$ is the parameter as proposed by Opper and Archambeau for the mean of the predictive distribution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8b2670ec",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:00:43.744437Z",
     "iopub.status.busy": "2022-03-18T10:00:43.744167Z",
     "iopub.status.idle": "2022-03-18T10:00:45.243689Z",
     "shell.execute_reply": "2022-03-18T10:00:45.243240Z"
    }
   },
   "outputs": [],
   "source": [
    "import gpflow\n",
    "import numpy as np\n",
    "\n",
    "# Create some data\n",
    "X = np.linspace(-1.1, 1.1, 1000)[:, None]\n",
    "Y = np.sin(X)\n",
    "Xnew = np.linspace(-1.1, 1.1, 1000)[:, None]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4ad612c",
   "metadata": {
    "id": "FzCgor4nKUcW"
   },
   "source": [
    "\n",
    "## GPR Example\n",
    "\n",
    "We will construct a GPR model to demonstrate the faster predictions from using the cached data in the GPFlow posterior classes (subclasses of `gpflow.posteriors.AbstractPosterior`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "23ed51b1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:00:45.245606Z",
     "iopub.status.busy": "2022-03-18T10:00:45.245498Z",
     "iopub.status.idle": "2022-03-18T10:00:45.299566Z",
     "shell.execute_reply": "2022-03-18T10:00:45.299052Z"
    },
    "id": "BMnIdXNiKU6t"
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-03-18 10:00:45.275884: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:936] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n",
      "2022-03-18 10:00:45.279292: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcusolver.so.11'; dlerror: libcusolver.so.11: cannot open shared object file: No such file or directory\n",
      "2022-03-18 10:00:45.279800: W tensorflow/core/common_runtime/gpu/gpu_device.cc:1850] Cannot dlopen some GPU libraries. Please make sure the missing libraries mentioned above are installed properly if you would like to use GPU. Follow the guide at https://www.tensorflow.org/install/gpu for how to download and setup the required libraries for your platform.\n",
      "Skipping registering GPU devices...\n",
      "2022-03-18 10:00:45.280549: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 FMA\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n"
     ]
    }
   ],
   "source": [
    "model = gpflow.models.GPR(\n",
    "    (X, Y),\n",
    "    gpflow.kernels.SquaredExponential(),\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a57abcb",
   "metadata": {},
   "source": [
    "The `predict_f` method on the `GPModel` class performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "a598e8e3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:00:45.301278Z",
     "iopub.status.busy": "2022-03-18T10:00:45.301142Z",
     "iopub.status.idle": "2022-03-18T10:00:54.838324Z",
     "shell.execute_reply": "2022-03-18T10:00:54.837887Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "117 ms ± 349 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f8a26c11",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:00:54.840071Z",
     "iopub.status.busy": "2022-03-18T10:00:54.839932Z",
     "iopub.status.idle": "2022-03-18T10:00:54.951433Z",
     "shell.execute_reply": "2022-03-18T10:00:54.950953Z"
    }
   },
   "outputs": [],
   "source": [
    "# To make use of the caching, first retrieve the posterior class from the model. The posterior class has methods to predict the parameters of marginal distributions at test points, in the same way as the `predict_f` method of the `GPModel`.\n",
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "85eed489",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:00:54.953313Z",
     "iopub.status.busy": "2022-03-18T10:00:54.953175Z",
     "iopub.status.idle": "2022-03-18T10:01:00.566475Z",
     "shell.execute_reply": "2022-03-18T10:01:00.566148Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "69.4 ms ± 547 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a1597f42",
   "metadata": {},
   "source": [
    "## SVGP Example\n",
    "\n",
    "Likewise, we will construct an SVGP model to demonstrate the faster predictions from using the cached data in the GPFlow posterior classes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "18823c19",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:00.568447Z",
     "iopub.status.busy": "2022-03-18T10:01:00.568005Z",
     "iopub.status.idle": "2022-03-18T10:01:00.598273Z",
     "shell.execute_reply": "2022-03-18T10:01:00.597830Z"
    },
    "id": "BMnIdXNiKU6t"
   },
   "outputs": [],
   "source": [
    "model = gpflow.models.SVGP(\n",
    "    gpflow.kernels.SquaredExponential(),\n",
    "    gpflow.likelihoods.Gaussian(),\n",
    "    np.linspace(-1.1, 1.1, 1000)[:, None],\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "14a0710c",
   "metadata": {},
   "source": [
    "The `predict_f` method on the `GPModel` class performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "536a26d8",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:00.600173Z",
     "iopub.status.busy": "2022-03-18T10:01:00.600039Z",
     "iopub.status.idle": "2022-03-18T10:01:09.909521Z",
     "shell.execute_reply": "2022-03-18T10:01:09.909071Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "115 ms ± 290 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb754780",
   "metadata": {},
   "source": [
    "And again using the posterior object and caching"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "4d131e54",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:09.911234Z",
     "iopub.status.busy": "2022-03-18T10:01:09.911055Z",
     "iopub.status.idle": "2022-03-18T10:01:10.055458Z",
     "shell.execute_reply": "2022-03-18T10:01:10.054941Z"
    }
   },
   "outputs": [],
   "source": [
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "027a9737",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:10.057329Z",
     "iopub.status.busy": "2022-03-18T10:01:10.057219Z",
     "iopub.status.idle": "2022-03-18T10:01:12.563411Z",
     "shell.execute_reply": "2022-03-18T10:01:12.562980Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "30.9 ms ± 32.7 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cdec0449",
   "metadata": {},
   "source": [
    "## SGPR Example\n",
    "\n",
    "And finally, we follow the same approach this time for the SGPR case."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "cd1be363",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:12.565165Z",
     "iopub.status.busy": "2022-03-18T10:01:12.565056Z",
     "iopub.status.idle": "2022-03-18T10:01:12.579178Z",
     "shell.execute_reply": "2022-03-18T10:01:12.578754Z"
    }
   },
   "outputs": [],
   "source": [
    "model = gpflow.models.SGPR(\n",
    "    (X, Y), gpflow.kernels.SquaredExponential(), np.linspace(-1.1, 1.1, 1000)[:, None]\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6f579a4c",
   "metadata": {},
   "source": [
    "The predict_f method on the instance performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "7eb1c980",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:12.580989Z",
     "iopub.status.busy": "2022-03-18T10:01:12.580879Z",
     "iopub.status.idle": "2022-03-18T10:01:14.300226Z",
     "shell.execute_reply": "2022-03-18T10:01:14.299872Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "214 ms ± 1.93 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dd8321ae",
   "metadata": {},
   "source": [
    "Using the posterior object instead:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "4dde1db3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:14.301930Z",
     "iopub.status.busy": "2022-03-18T10:01:14.301797Z",
     "iopub.status.idle": "2022-03-18T10:01:14.669064Z",
     "shell.execute_reply": "2022-03-18T10:01:14.668584Z"
    }
   },
   "outputs": [],
   "source": [
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "27365b34",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-03-18T10:01:14.670887Z",
     "iopub.status.busy": "2022-03-18T10:01:14.670780Z",
     "iopub.status.idle": "2022-03-18T10:01:17.263893Z",
     "shell.execute_reply": "2022-03-18T10:01:17.263474Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "32 ms ± 59.4 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

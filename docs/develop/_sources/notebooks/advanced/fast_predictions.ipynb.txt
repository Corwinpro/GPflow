{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e03da5f7",
   "metadata": {
    "id": "eYrSpUncKGSk"
   },
   "source": [
    "# Faster predictions by caching"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7b671e5a",
   "metadata": {
    "id": "PLuPjfS7KLQ-"
   },
   "source": [
    "The default behaviour of `predict_f` in GPflow models is to compute the predictions from scratch on each call. This is convenient when predicting and training are interleaved, and simplifies the use of these models. There are some use cases, such as Bayesian optimisation, where prediction (at different test points) happens much more frequently than training. In these cases it is convenient to cache parts of the calculation which do not depend upon the test points, and reuse those parts between predictions.\n",
    "\n",
    "There are three models to which we want to add this caching capability: GPR, (S)VGP and SGPR. The VGP and SVGP can be considered together; the difference between the models is whether to condition on the full training data set (VGP) or on the inducing variables (SVGP)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13a2d9a2",
   "metadata": {
    "id": "EACkO-iRKM5T"
   },
   "source": [
    "## Posterior predictive distribution\n",
    "\n",
    "The posterior predictive distribution evaluated at a set of test points $\\mathbf{x}_*$ for a Gaussian process model is given by:\n",
    "\\begin{equation*}\n",
    "p(\\mathbf{f}_*|X, Y) = \\mathcal{N}(\\mu, \\Sigma)\n",
    "\\end{equation*}\n",
    "\n",
    "In the case of the GPR model, the parameters $\\mu$ and $\\Sigma$ are given by:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nm}[K_{mm} + \\sigma^2I]^{-1}\\mathbf{y}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nm}[K_{mm} + \\sigma^2I]^{-1}K_{mn}\n",
    "\\end{equation*}\n",
    "\n",
    "The posterior predictive distribution for the VGP and SVGP model is parameterised as follows:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nu}K_{uu}^{-1}\\mathbf{u}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nu}K_{uu}^{-1}K_{un}\n",
    "\\end{equation*}\n",
    "\n",
    "Finally, the parameters for the SGPR model are:\n",
    "\\begin{equation*}\n",
    "\\mu = K_{nu}L^{-T}L_B^{-T}\\mathbf{c}\n",
    "\\end{equation*}\n",
    "and\n",
    "\\begin{equation*}\n",
    "\\Sigma = K_{nn} - K_{nu}L^{-T}(I - B^{-1})L^{-1}K_{un}\n",
    "\\end{equation*}\n",
    "\n",
    "Where the mean function is not the zero function, the predictive mean should have the mean function evaluated at the test points added to it."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4e85e82c",
   "metadata": {
    "id": "GX1U-fYPKPrt"
   },
   "source": [
    "## What can be cached?\n",
    "\n",
    "We cache two separate values: $\\alpha$ and $Q^{-1}$. These correspond to the parts of the mean and covariance functions respectively which do not depend upon the test points. In the case of the GPR these are the same value:\n",
    "\\begin{equation*}\n",
    "    \\alpha = Q^{-1} = [K_{mm} + \\sigma^2I]^{-1}\n",
    "\\end{equation*}\n",
    "in the case of the VGP and SVGP model these are:\n",
    "\\begin{equation*}\n",
    "    \\alpha = K_{uu}^{-1}\\mathbf{u}\\\\ Q^{-1} = K_{uu}^{-1}\n",
    "\\end{equation*}\n",
    "and in the case of the SGPR model these are:\n",
    "\\begin{equation*}\n",
    "    \\alpha = L^{-T}L_B^{-T}\\mathbf{c}\\\\ Q^{-1} = L^{-T}(I - B^{-1})L^{-1}\n",
    "\\end{equation*}\n",
    "\n",
    "\n",
    "Note that in the (S)VGP case, $\\alpha$ is the parameter as proposed by Opper and Archambeau for the mean of the predictive distribution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "383dadfe",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:14.531478Z",
     "iopub.status.busy": "2022-04-12T14:34:14.531261Z",
     "iopub.status.idle": "2022-04-12T14:34:17.060918Z",
     "shell.execute_reply": "2022-04-12T14:34:17.060274Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-04-12 14:34:14.708137: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcudart.so.11.0'; dlerror: libcudart.so.11.0: cannot open shared object file: No such file or directory\n",
      "2022-04-12 14:34:14.708165: I tensorflow/stream_executor/cuda/cudart_stub.cc:29] Ignore above cudart dlerror if you do not have a GPU set up on your machine.\n"
     ]
    }
   ],
   "source": [
    "import gpflow\n",
    "import numpy as np\n",
    "\n",
    "# Create some data\n",
    "X = np.linspace(-1.1, 1.1, 1000)[:, None]\n",
    "Y = np.sin(X)\n",
    "Xnew = np.linspace(-1.1, 1.1, 1000)[:, None]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3086103a",
   "metadata": {
    "id": "FzCgor4nKUcW"
   },
   "source": [
    "\n",
    "## GPR Example\n",
    "\n",
    "We will construct a GPR model to demonstrate the faster predictions from using the cached data in the GPFlow posterior classes (subclasses of `gpflow.posteriors.AbstractPosterior`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "13d4758a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:17.063845Z",
     "iopub.status.busy": "2022-04-12T14:34:17.063626Z",
     "iopub.status.idle": "2022-04-12T14:34:17.099405Z",
     "shell.execute_reply": "2022-04-12T14:34:17.098898Z"
    },
    "id": "BMnIdXNiKU6t"
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2022-04-12 14:34:17.065492: W tensorflow/stream_executor/platform/default/dso_loader.cc:64] Could not load dynamic library 'libcuda.so.1'; dlerror: libcuda.so.1: cannot open shared object file: No such file or directory\n",
      "2022-04-12 14:34:17.065523: W tensorflow/stream_executor/cuda/cuda_driver.cc:269] failed call to cuInit: UNKNOWN ERROR (303)\n",
      "2022-04-12 14:34:17.065543: I tensorflow/stream_executor/cuda/cuda_diagnostics.cc:156] kernel driver does not appear to be running on this host (ff15def5dec8): /proc/driver/nvidia/version does not exist\n",
      "2022-04-12 14:34:17.065823: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX2 AVX512F FMA\n",
      "To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.\n"
     ]
    }
   ],
   "source": [
    "model = gpflow.models.GPR(\n",
    "    (X, Y),\n",
    "    gpflow.kernels.SquaredExponential(),\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd354320",
   "metadata": {},
   "source": [
    "The `predict_f` method on the `GPModel` class performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "d1944914",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:17.101670Z",
     "iopub.status.busy": "2022-04-12T14:34:17.101480Z",
     "iopub.status.idle": "2022-04-12T14:34:18.502488Z",
     "shell.execute_reply": "2022-04-12T14:34:18.501979Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "165 ms ± 6.26 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b2ac686b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:18.504741Z",
     "iopub.status.busy": "2022-04-12T14:34:18.504525Z",
     "iopub.status.idle": "2022-04-12T14:34:18.647952Z",
     "shell.execute_reply": "2022-04-12T14:34:18.647429Z"
    }
   },
   "outputs": [],
   "source": [
    "# To make use of the caching, first retrieve the posterior class from the model. The posterior class has methods to predict the parameters of marginal distributions at test points, in the same way as the `predict_f` method of the `GPModel`.\n",
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "52f62b2c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:18.650652Z",
     "iopub.status.busy": "2022-04-12T14:34:18.650410Z",
     "iopub.status.idle": "2022-04-12T14:34:33.413655Z",
     "shell.execute_reply": "2022-04-12T14:34:33.412087Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "182 ms ± 3.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a1d27cd8",
   "metadata": {},
   "source": [
    "## SVGP Example\n",
    "\n",
    "Likewise, we will construct an SVGP model to demonstrate the faster predictions from using the cached data in the GPFlow posterior classes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "72e190cc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:33.416466Z",
     "iopub.status.busy": "2022-04-12T14:34:33.416160Z",
     "iopub.status.idle": "2022-04-12T14:34:33.519055Z",
     "shell.execute_reply": "2022-04-12T14:34:33.518498Z"
    },
    "id": "BMnIdXNiKU6t"
   },
   "outputs": [],
   "source": [
    "model = gpflow.models.SVGP(\n",
    "    gpflow.kernels.SquaredExponential(),\n",
    "    gpflow.likelihoods.Gaussian(),\n",
    "    np.linspace(-1.1, 1.1, 1000)[:, None],\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cd03dcb5",
   "metadata": {},
   "source": [
    "The `predict_f` method on the `GPModel` class performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6f2128d0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:33.522151Z",
     "iopub.status.busy": "2022-04-12T14:34:33.521906Z",
     "iopub.status.idle": "2022-04-12T14:34:50.297940Z",
     "shell.execute_reply": "2022-04-12T14:34:50.297414Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "207 ms ± 4.47 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30f8face",
   "metadata": {},
   "source": [
    "And again using the posterior object and caching"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "50c93ceb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:50.301460Z",
     "iopub.status.busy": "2022-04-12T14:34:50.301190Z",
     "iopub.status.idle": "2022-04-12T14:34:50.544323Z",
     "shell.execute_reply": "2022-04-12T14:34:50.543824Z"
    }
   },
   "outputs": [],
   "source": [
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "87a5569f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:50.547104Z",
     "iopub.status.busy": "2022-04-12T14:34:50.546884Z",
     "iopub.status.idle": "2022-04-12T14:34:58.396856Z",
     "shell.execute_reply": "2022-04-12T14:34:58.396099Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "97.2 ms ± 4.14 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15a18685",
   "metadata": {},
   "source": [
    "## SGPR Example\n",
    "\n",
    "And finally, we follow the same approach this time for the SGPR case."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "735d6645",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:58.400559Z",
     "iopub.status.busy": "2022-04-12T14:34:58.400269Z",
     "iopub.status.idle": "2022-04-12T14:34:58.432508Z",
     "shell.execute_reply": "2022-04-12T14:34:58.431876Z"
    }
   },
   "outputs": [],
   "source": [
    "model = gpflow.models.SGPR(\n",
    "    (X, Y), gpflow.kernels.SquaredExponential(), np.linspace(-1.1, 1.1, 1000)[:, None]\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dfad9e5b",
   "metadata": {},
   "source": [
    "The predict_f method on the instance performs no caching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "2fa8dec1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:34:58.436187Z",
     "iopub.status.busy": "2022-04-12T14:34:58.435850Z",
     "iopub.status.idle": "2022-04-12T14:35:00.947505Z",
     "shell.execute_reply": "2022-04-12T14:35:00.946900Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "303 ms ± 21 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "model.predict_f(Xnew)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "101e2297",
   "metadata": {},
   "source": [
    "Using the posterior object instead:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "da6cfc81",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:35:00.949801Z",
     "iopub.status.busy": "2022-04-12T14:35:00.949583Z",
     "iopub.status.idle": "2022-04-12T14:35:01.593578Z",
     "shell.execute_reply": "2022-04-12T14:35:01.592929Z"
    }
   },
   "outputs": [],
   "source": [
    "posterior = model.posterior()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "bb9c7773",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2022-04-12T14:35:01.596413Z",
     "iopub.status.busy": "2022-04-12T14:35:01.596175Z",
     "iopub.status.idle": "2022-04-12T14:35:09.797819Z",
     "shell.execute_reply": "2022-04-12T14:35:09.797313Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "102 ms ± 3.17 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "posterior.predict_f(Xnew)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
